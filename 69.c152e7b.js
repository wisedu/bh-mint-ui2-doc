webpackJsonp([69],{210:function(t,s){t.exports="<section><h1>Loadmore</h1> <blockquote> <p>A two-direction pull-to-refresh component. Custom HTML templates supported.</p> </blockquote> <hr> <h2>Import</h2> <pre><code class=language-javascript><span class=hljs-keyword>import</span> { Loadmore } <span class=hljs-keyword>from</span> <span class=hljs-string>'mint-ui'</span>;\n\nVue.component(Loadmore.name, Loadmore);\n</code></pre> <h2>Example</h2> <pre><code class=language-html><span class=hljs-tag>&lt;<span class=hljs-name>mt-loadmore</span> <span class=hljs-attr>:top-method</span>=<span class=hljs-string>\"loadTop\"</span> <span class=hljs-attr>:bottom-method</span>=<span class=hljs-string>\"loadBottom\"</span> <span class=hljs-attr>:bottom-all-loaded</span>=<span class=hljs-string>\"allLoaded\"</span> <span class=hljs-attr>ref</span>=<span class=hljs-string>\"loadmore\"</span>&gt;</span>\n  <span class=hljs-tag>&lt;<span class=hljs-name>ul</span>&gt;</span>\n    <span class=hljs-tag>&lt;<span class=hljs-name>li</span> <span class=hljs-attr>v-for</span>=<span class=hljs-string>\"item in list\"</span>&gt;</span><span>{{</span> item <span>}}</span><span class=hljs-tag>&lt;/<span class=hljs-name>li</span>&gt;</span>\n  <span class=hljs-tag>&lt;/<span class=hljs-name>ul</span>&gt;</span>\n<span class=hljs-tag>&lt;/<span class=hljs-name>mt-loadmore</span>&gt;</span>\n</code></pre> <p>Take upward direction for example: pull the component <code>topDistance</code> pixels away from the top and then release it, the function you appointed as <code>top-method</code> will run</p> <pre><code class=language-javascript>loadTop() {\n  ...<span class=hljs-comment>// load more data</span>\n  <span class=hljs-keyword>this</span>.$refs.loadmore.onTopLoaded();\n}\n</code></pre> <p>At the end of your <code>top-method</code>, don't forget to manually execute the <code>onTopLoaded</code> event so that <code>mint-loadmore</code> removes <code>topLoadingText</code>. This is because after the top data is loaded, some reposition work is performed inside a <code>mint-loadmore</code> instance.</p> <p>For downward direction, things are similar. To invoke <code>bottom-method</code>, just pull the component <code>bottomDistance</code> pixels away from the bottom and then release it</p> <pre><code class=language-javascript>loadBottom() {\n  ...<span class=hljs-comment>// load more data</span>\n  <span class=hljs-keyword>this</span>.allLoaded = <span class=hljs-literal>true</span>;<span class=hljs-comment>// if all data are loaded</span>\n  <span class=hljs-keyword>this</span>.$refs.loadmore.onBottomLoaded();\n}\n</code></pre> <p>The only difference is that after all data are fetched, you can set <code>bottom-all-loaded</code> to <code>true</code> so that <code>bottom-method</code> will not run any more.</p> <p>The ratio between the distance that your finger moves and the distance that the component actually scrolls can be defined using <code>distance-index</code>, whose default value is 2。</p> <h2>Custom HTML templates</h2> <p>You can customize the top and bottom DOM using an HTML template</p> <pre><code class=language-html><span class=hljs-tag>&lt;<span class=hljs-name>mt-loadmore</span> <span class=hljs-attr>:top-method</span>=<span class=hljs-string>\"loadTop\"</span> <span class=hljs-attr>:top-status.sync</span>=<span class=hljs-string>\"topStatus\"</span>&gt;</span>\n  <span class=hljs-tag>&lt;<span class=hljs-name>ul</span>&gt;</span>\n    <span class=hljs-tag>&lt;<span class=hljs-name>li</span> <span class=hljs-attr>v-for</span>=<span class=hljs-string>\"item in list\"</span>&gt;</span><span>{{</span> item <span>}}</span><span class=hljs-tag>&lt;/<span class=hljs-name>li</span>&gt;</span>\n  <span class=hljs-tag>&lt;/<span class=hljs-name>ul</span>&gt;</span>\n  <span class=hljs-tag>&lt;<span class=hljs-name>div</span> <span class=hljs-attr>slot</span>=<span class=hljs-string>\"top\"</span> <span class=hljs-attr>class</span>=<span class=hljs-string>\"mint-loadmore-top\"</span>&gt;</span>\n    <span class=hljs-tag>&lt;<span class=hljs-name>span</span> <span class=hljs-attr>v-show</span>=<span class=hljs-string>\"topStatus !== 'loading'\"</span> <span class=hljs-attr>:class</span>=<span class=hljs-string>\"{ 'rotate': topStatus === 'drop' }\"</span>&gt;</span>↓<span class=hljs-tag>&lt;/<span class=hljs-name>span</span>&gt;</span>\n    <span class=hljs-tag>&lt;<span class=hljs-name>span</span> <span class=hljs-attr>v-show</span>=<span class=hljs-string>\"topStatus === 'loading'\"</span>&gt;</span>Loading...<span class=hljs-tag>&lt;/<span class=hljs-name>span</span>&gt;</span>\n  <span class=hljs-tag>&lt;/<span class=hljs-name>div</span>&gt;</span>\n<span class=hljs-tag>&lt;/<span class=hljs-name>mt-loadmore</span>&gt;</span>\n</code></pre> <p>For example, to customize the top DOM, you'll need to write your template with a <code>slot</code> attribute set to <code>top</code> and <code>class</code> set to <code>mint-loadmore-top</code>. When the component is scrolled, it will be in one of the three status below</p> <ul> <li><code>pull</code>: if the component is being pulled yet not ready to drop (top distance is within the distance threshold defined by <code>topDistance</code>)</li> <li><code>drop</code>: if the component is ready to drop</li> <li><code>loading</code>: if <code>topMethod</code> is running Every time the status changes, an event named <code>top-status-change</code> fires with a parameter indicating the current status of the component. So you can handle this change with a <code>handleTopChange</code> method just as the above example shows.</li> </ul> <h2>Configure texts in top and bottom DOM</h2> <p>If you decide not to customize HTML templates, you can configure the texts that comes with <code>loadmore</code>. Take the top DOM for example, corresponding to the three <code>top-status</code> states, configurable options are: <code>topPullText</code>, <code>topDropText</code> and <code>topLoadingText</code>. And <code>bottomPullText</code>, <code>bottomDropText</code> and <code>bottomLoadingText</code> are for the bottom DOM.</p> <h2>Auto fill</h2> <p>Upon loaded, <code>loadmore</code> will automatically check if it is tall enough to fill its container. If not, <code>bottom-method</code> will run until its container is filled. Turn off <code>auto-fill</code> if you'd rather handle this manually.</p> <h2>API</h2> <div class=table-container><table class=table><thead> <tr> <th>option</th> <th>description</th> <th>type</th> <th>acceptable values</th> <th>default</th> </tr> </thead> <tbody> <tr> <td>autoFill</td> <td>if <code>true</code>, <code>loadmore</code> will check and fill its container</td> <td>Boolean</td> <td></td> <td>true</td> </tr> <tr> <td>distanceIndex</td> <td>the ratio between the distance of the finger moves and the component scrolls</td> <td>Number</td> <td></td> <td>2</td> </tr> <tr> <td>maxDistance</td> <td>maximum distance(in pixel) the component can scroll. Can be disabled by setting it to 0</td> <td>Number</td> <td></td> <td>0</td> </tr> <tr> <td>topPullText</td> <td>top text when the component is being pulled down</td> <td>String</td> <td></td> <td>'下拉刷新'</td> </tr> <tr> <td>topDropText</td> <td>top text when the component is ready to drop</td> <td>String</td> <td></td> <td>'释放更新'</td> </tr> <tr> <td>topLoadingText</td> <td>top text while <code>topMethod</code> is running</td> <td>String</td> <td></td> <td>'加载中...'</td> </tr> <tr> <td>topDistance</td> <td>distance threshold that triggers <code>topMethod</code>(in pixel)</td> <td>Number</td> <td></td> <td>70</td> </tr> <tr> <td>topMethod</td> <td>upward load-more function</td> <td>Function</td> <td></td> <td></td> </tr> <tr> <td>bottomPullText</td> <td>bottom text when the component is being pulled up</td> <td>String</td> <td></td> <td>'上拉刷新'</td> </tr> <tr> <td>bottomDropText</td> <td>bottom text when the component is ready to drop</td> <td>String</td> <td></td> <td>'释放更新'</td> </tr> <tr> <td>bottomLoadingText</td> <td>bottom text while <code>bottomMethod</code> is running</td> <td>String</td> <td></td> <td>'加载中...'</td> </tr> <tr> <td>bottomDistance</td> <td>distance threshold that triggers <code>bottomMethod</code>(in pixel)</td> <td>Number</td> <td></td> <td>70</td> </tr> <tr> <td>bottomMethod</td> <td>downward load-more function</td> <td>Function</td> <td></td> <td></td> </tr> <tr> <td>bottomAllLoaded</td> <td>if <code>true</code>, <code>bottomMethod</code> can no longer be triggered</td> <td>Boolean</td> <td></td> <td>false</td> </tr> </tbody> </table></div><h2>Events</h2> <div class=table-container><table class=table><thead> <tr> <th>event name</th> <th>description</th> <th>parameters</th> </tr> </thead> <tbody> <tr> <td>top-status-change</td> <td>the callback when the component's top status changes</td> <td>current top status</td> </tr> <tr> <td>bottom-status-change</td> <td>the callback when the component's bottom status changes</td> <td>current bottom status</td> </tr> </tbody> </table></div><h2>Slot</h2> <div class=table-container><table class=table><thead> <tr> <th>name</th> <th>description</th> </tr> </thead> <tbody> <tr> <td>-</td> <td>data list</td> </tr> <tr> <td>top</td> <td>custom top HTML template</td> </tr> <tr> <td>bottom</td> <td>custom bottom HTML template</td> </tr> </tbody> </table></div></section>"},337:function(t,s,a){var e,o,n={};o=a(210),t.exports=e||{},t.exports.__esModule&&(t.exports=t.exports.default);var d="function"==typeof t.exports?t.exports.options||(t.exports.options={}):t.exports;o&&(d.template=o),d.computed||(d.computed={}),Object.keys(n).forEach(function(t){var s=n[t];d.computed[t]=function(){return s}})},68:function(t,s,a){t.exports=a(337)}});