webpackJsonp([67],{100:function(t,s,a){t.exports=a(339)},212:function(t,s){t.exports="<section><h1>Loadmore</h1> <blockquote> <p>下拉/上拉刷新，支持自定义 HTML 模板。</p> </blockquote> <hr> <h2>引入</h2> <pre><code class=language-javascript><span class=hljs-keyword>import</span> { Loadmore } <span class=hljs-keyword>from</span> <span class=hljs-string>'mint-ui'</span>;\n\nVue.component(Loadmore.name, Loadmore);\n</code></pre> <h2>例子</h2> <pre><code class=language-html><span class=hljs-tag>&lt;<span class=hljs-name>mt-loadmore</span> <span class=hljs-attr>:top-method</span>=<span class=hljs-string>\"loadTop\"</span> <span class=hljs-attr>:bottom-method</span>=<span class=hljs-string>\"loadBottom\"</span> <span class=hljs-attr>:bottom-all-loaded</span>=<span class=hljs-string>\"allLoaded\"</span>&gt;</span>\n  <span class=hljs-tag>&lt;<span class=hljs-name>ul</span>&gt;</span>\n    <span class=hljs-tag>&lt;<span class=hljs-name>li</span> <span class=hljs-attr>v-for</span>=<span class=hljs-string>\"item in list\"</span>&gt;</span><span>{{</span> item <span>}}</span><span class=hljs-tag>&lt;/<span class=hljs-name>li</span>&gt;</span>\n  <span class=hljs-tag>&lt;/<span class=hljs-name>ul</span>&gt;</span>\n<span class=hljs-tag>&lt;/<span class=hljs-name>mt-loadmore</span>&gt;</span>\n</code></pre> <p>以列表顶部的下拉刷新为例：按住列表，下拉一定距离（通过 <code>topDistance</code> 配置）后释放，被指定为 <code>top-method</code> 的方法就会执行</p> <pre><code class=language-javascript>loadTop(id) {\n  ...<span class=hljs-comment>// 加载更多数据</span>\n  <span class=hljs-keyword>this</span>.$broadcast(<span class=hljs-string>'onTopLoaded'</span>, id);\n}\n</code></pre> <p>注意在这个方法的最后需要广播 <code>onTopLoaded</code> 事件，参数为 <code>id</code>。这是因为在加载数据后需要对组件进行一些重新定位的操作，<code>id</code> 参数能够避免在同一页面有多个 <code>loadmore</code> 实例时互相干扰。</p> <p>列表底部的上拉刷新与之类似</p> <pre><code class=language-javascript>loadBottom(id) {\n  ...<span class=hljs-comment>// 加载更多数据</span>\n  <span class=hljs-keyword>this</span>.allLoaded = <span class=hljs-literal>true</span>;<span class=hljs-comment>// 若数据已全部获取完毕</span>\n  <span class=hljs-keyword>this</span>.$broadcast(<span class=hljs-string>'onBottomLoaded'</span>, id);\n}\n</code></pre> <p>唯一的区别是，当底部数据全部获取完毕时，可以将绑定到组件 <code>bottom-all-loaded</code> 属性的变量赋值为 <code>true</code>，这样 <code>bottom-method</code> 就不会再次执行了。</p> <h2>自定义 HTML 模板</h2> <p>可以为列表顶部和底部的加载提示区域提供自定义的 HTML 模板</p> <pre><code class=language-html><span class=hljs-tag>&lt;<span class=hljs-name>mt-loadmore</span> <span class=hljs-attr>:top-method</span>=<span class=hljs-string>\"loadTop\"</span> <span class=hljs-attr>:top-status.sync</span>=<span class=hljs-string>\"topStatus\"</span>&gt;</span>\n  <span class=hljs-tag>&lt;<span class=hljs-name>ul</span>&gt;</span>\n    <span class=hljs-tag>&lt;<span class=hljs-name>li</span> <span class=hljs-attr>v-for</span>=<span class=hljs-string>\"item in list\"</span>&gt;</span><span>{{</span> item <span>}}</span><span class=hljs-tag>&lt;/<span class=hljs-name>li</span>&gt;</span>\n  <span class=hljs-tag>&lt;/<span class=hljs-name>ul</span>&gt;</span>\n  <span class=hljs-tag>&lt;<span class=hljs-name>div</span> <span class=hljs-attr>slot</span>=<span class=hljs-string>\"top\"</span> <span class=hljs-attr>class</span>=<span class=hljs-string>\"mint-loadmore-top\"</span>&gt;</span>\n    <span class=hljs-tag>&lt;<span class=hljs-name>span</span> <span class=hljs-attr>v-show</span>=<span class=hljs-string>\"topStatus !== 'loading'\"</span> <span class=hljs-attr>:class</span>=<span class=hljs-string>\"{ 'rotate': topStatus === 'drop' }\"</span>&gt;</span>↓<span class=hljs-tag>&lt;/<span class=hljs-name>span</span>&gt;</span>\n    <span class=hljs-tag>&lt;<span class=hljs-name>span</span> <span class=hljs-attr>v-show</span>=<span class=hljs-string>\"topStatus === 'loading'\"</span>&gt;</span>Loading...<span class=hljs-tag>&lt;/<span class=hljs-name>span</span>&gt;</span>\n  <span class=hljs-tag>&lt;/<span class=hljs-name>div</span>&gt;</span>\n<span class=hljs-tag>&lt;/<span class=hljs-name>mt-loadmore</span>&gt;</span>\n</code></pre> <p>比如需要配置列表顶部的 HTML，则需要在 <code>loadmore</code> 标签上添加一个与 <code>top-status</code> 同步的变量，同时为自定义 HTML 模板的最外层标签设置 <code>slot</code> 属性为 <code>top</code>，类名为 <code>mint-loadmore-top</code>。<code>top-status</code> 有三个可能的值，表示组件目前所处的状态：</p> <ul> <li><code>pull</code>：组件已经被按下，但按下的距离未达到 <code>topDistance</code>，此时释放不会触发 <code>top-method</code>，列表会回到初始位置</li> <li><code>drop</code>：按下的距离不小于 <code>topDistance</code>，此时释放会触发 <code>top-method</code></li> <li><code>loading</code>：组件已被释放，<code>top-method</code> 正在执行</li> </ul> <h2>配置加载提示区域的文字</h2> <p>在不使用自定义 HTML 模板的情况下，可以配置 <code>loadmore</code> 本身自带的加载提示区域的文字。以列表顶部为例，对应于 <code>top-status</code> 的三个状态，可配置的属性依次为 <code>topPullText</code>、<code>topDropText</code> 和 <code>topLoadingText</code>。与之对应的底部属性为 <code>bottomPullText</code>、<code>bottomDropText</code> 和 <code>bottomLoadingText</code>。</p> <h2>自动检测</h2> <p><code>loadmore</code> 在初始化时会自动检测它的高度是否能够撑满其容器，如果不能则会调用 <code>bottom-method</code>，直到撑满容器为止。如果不希望使用这一机制，可以将 <code>auto-fill</code> 设为 <code>false</code>。</p> <h2>API</h2> <div class=table-container><table class=table><thead> <tr> <th>参数</th> <th>说明</th> <th>类型</th> <th>可选值</th> <th>默认值</th> </tr> </thead> <tbody> <tr> <td>autoFill</td> <td>若为真，<code>loadmore</code> 会自动检测并撑满其容器</td> <td>Boolean</td> <td></td> <td>true</td> </tr> <tr> <td>topPullText</td> <td><code>topStatus</code> 为 <code>pull</code> 时加载提示区域的文字</td> <td>String</td> <td></td> <td>'下拉刷新'</td> </tr> <tr> <td>topDropText</td> <td><code>topStatus</code> 为 <code>drop</code> 时加载提示区域的文字</td> <td>String</td> <td></td> <td>'释放更新'</td> </tr> <tr> <td>topLoadingText</td> <td><code>topStatus</code> 为 <code>loading</code> 时加载提示区域的文字</td> <td>String</td> <td></td> <td>'加载中...'</td> </tr> <tr> <td>topDistance</td> <td>触发 <code>topMethod</code> 的下拉距离阈值（像素）</td> <td>Number</td> <td></td> <td>70</td> </tr> <tr> <td>topMethod</td> <td>下拉刷新执行的方法</td> <td>Function</td> <td></td> <td></td> </tr> <tr> <td>bottomPullText</td> <td><code>bottomStatus</code> 为 <code>pull</code> 时加载提示区域的文字</td> <td>String</td> <td></td> <td>'上拉刷新'</td> </tr> <tr> <td>bottomDropText</td> <td><code>bottomStatus</code> 为 <code>drop</code> 时加载提示区域的文字</td> <td>String</td> <td></td> <td>'释放更新'</td> </tr> <tr> <td>bottomLoadingText</td> <td><code>bottomStatus</code> 为 <code>loading</code> 时加载提示区域的文字</td> <td>String</td> <td></td> <td>'加载中...'</td> </tr> <tr> <td>bottomDistance</td> <td>触发 <code>bottomMethod</code> 的上拉距离阈值（像素）</td> <td>Number</td> <td></td> <td>70</td> </tr> <tr> <td>bottomMethod</td> <td>上拉刷新执行的方法</td> <td>Function</td> <td></td> <td></td> </tr> <tr> <td>bottomAllLoaded</td> <td>若为真，则 <code>bottomMethod</code> 不会被再次触发</td> <td>Boolean</td> <td></td> <td>false</td> </tr> </tbody> </table></div><h2>Slot</h2> <div class=table-container><table class=table><thead> <tr> <th>name</th> <th>描述</th> </tr> </thead> <tbody> <tr> <td>-</td> <td>数据列表</td> </tr> <tr> <td>top</td> <td>自定义顶部加载提示区域 HTML 模板</td> </tr> <tr> <td>bottom</td> <td>自定义底部加载提示区域 HTML 模板</td> </tr> </tbody> </table></div></section>"},339:function(t,s,a){var o,d,n={};d=a(212),t.exports=o||{},t.exports.__esModule&&(t.exports=t.exports.default);var l="function"==typeof t.exports?t.exports.options||(t.exports.options={}):t.exports;d&&(l.template=d),l.computed||(l.computed={}),Object.keys(n).forEach(function(t){var s=n[t];l.computed[t]=function(){return s}})}});